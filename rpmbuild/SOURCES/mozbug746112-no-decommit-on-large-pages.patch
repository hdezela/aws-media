# See https://bugzilla.redhat.com/show_bug.cgi?id=971519
# HG changeset patch
# User Terrence Cole <terrence@mozilla.com>
# Date 1346874025 25200
# Node ID 0558ede9693e57663e4836c7e678b55465ddc2ab
# Parent  d28e07f4bec6c16b32ae4743eaeeae2a9e2f6381
Bug 746112 - Don't decommit if page size is too large; r=billm

The powerpc architecture has 64KiB pages, which is too large to represent in the
free list.  This patch splits the page size from the arena size and disabled
decommit logic in that case.

diff -up xulrunner-17.0/mozilla-beta/js/src/gc/Heap.h.746112 xulrunner-17.0/mozilla-beta/js/src/gc/Heap.h
--- a/js/src/gc/Heap.h.746112	2012-10-17 16:32:43.000000000 +0200
+++ b/js/src/gc/Heap.h	2012-10-24 14:48:12.186640489 +0200
@@ -103,26 +103,31 @@ struct Cell
 };
 
 /*
- * Page size is 4096 by default, except for SPARC, where it is 8192.
+ * Page size must be static to support our arena pointer optimizations, so we
+ * are forced to support each platform with non-4096 pages as a special case.
+ * Note: The freelist supports a maximum arena shift of 15.
  * Note: Do not use JS_CPU_SPARC here, this header is used outside JS.
  * Bug 692267: Move page size definition to gc/Memory.h and include it
  *             directly once jsgc.h is no longer an installed header.
  */
 #if defined(SOLARIS) && (defined(__sparc) || defined(__sparcv9))
 const size_t PageShift = 13;
+const size_t ArenaShift = PageShift;
+#elif defined(__powerpc__)
+const size_t PageShift = 16;
+const size_t ArenaShift = 12;
 #else
 const size_t PageShift = 12;
+const size_t ArenaShift = PageShift;
 #endif
 const size_t PageSize = size_t(1) << PageShift;
+const size_t ArenaSize = size_t(1) << ArenaShift;
+const size_t ArenaMask = ArenaSize - 1;
 
 const size_t ChunkShift = 20;
 const size_t ChunkSize = size_t(1) << ChunkShift;
 const size_t ChunkMask = ChunkSize - 1;
 
-const size_t ArenaShift = PageShift;
-const size_t ArenaSize = PageSize;
-const size_t ArenaMask = ArenaSize - 1;
-
 /*
  * This is the maximum number of arenas we allow in the FreeCommitted state
  * before we trigger a GC_SHRINK to release free arenas to the OS.
diff -up xulrunner-17.0/mozilla-beta/js/src/jsgc.cpp.746112 xulrunner-17.0/mozilla-beta/js/src/jsgc.cpp
--- a/js/src/jsgc.cpp.746112	2012-10-17 16:32:44.000000000 +0200
+++ b/js/src/jsgc.cpp	2012-10-24 14:46:28.253638095 +0200
@@ -251,6 +251,13 @@ static const int BackgroundPhaseLength[]
     sizeof(BackgroundPhaseStrings) / sizeof(AllocKind)
 };
 
+/* Unused memory decommiting requires the arena size match the page size. */
+static bool
+DecommitEnabled()
+{
+    return PageSize == ArenaSize;
+}
+
 #ifdef DEBUG
 void
 ArenaHeader::checkSynchronizedWithFreeList() const
@@ -742,7 +749,8 @@ Chunk::fetchNextDecommittedArena()
     decommittedArenas.unset(offset);
 
     Arena *arena = &arenas[offset];
-    MarkPagesInUse(arena, ArenaSize);
+    if (DecommitEnabled())
+        MarkPagesInUse(arena, ArenaSize);
     arena->aheader.setAsNotAllocated();
 
     return &arena->aheader;
@@ -2731,7 +2739,7 @@ DecommitArenasFromAvailableList(JSRuntim
                 chunk->removeFromAvailableList();
 
             size_t arenaIndex = Chunk::arenaIndex(aheader->arenaAddress());
-            bool ok;
+            bool ok = true;
             {
                 /*
                  * If the main thread waits for the decommit to finish, skip
@@ -2741,7 +2749,8 @@ DecommitArenasFromAvailableList(JSRuntim
                 Maybe<AutoUnlockGC> maybeUnlock;
                 if (!rt->isHeapBusy())
                     maybeUnlock.construct(rt);
-                ok = MarkPagesUnused(aheader->getArena(), ArenaSize);
+                if (DecommitEnabled())
+                    ok = MarkPagesUnused(aheader->getArena(), ArenaSize);
             }
 
             if (ok) {
